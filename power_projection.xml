<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, March 10, 2018, 10:56 PM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "power_projection" generated by Plugin Wizard -->

<muclient>
<plugin
   name="power_projection"
   author="Daak"
   id="2aa18e928a8dfef20a6a0703"
   language="Lua"
   purpose="Power Project miniwindow"
   save_state="y"
   date_written="2018-03-10 22:55:50"
   requires="5.06"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Keeps track of Power Project status in a miniwindow.

  pp check         - Forces the re-check of power project status
  pp ready         - Sets power projection to ready
  pp active        - Sets power projection to active
  pp limp          - Sets power projection recovery
  pp help          - Your looking at it

NOTE: Aliases are only to set states, plugins automatically switches state based on power projection triggers.
PS: The function names are pp, yes this is pee pee. Hah! All finished?
]]>
</description>
</plugin>

<!--  Get our standard constants -->
<include name="constants.lua"/>

<aliases>
  <alias
   script="pp_ready"
   match="^pp ready$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
  <alias
   script="pp_active"
   match="^pp active$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
  <alias
   script="pp_limp"
   match="^pp limp$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
  <alias
   script="pp_check"
   match="^pp check$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
  <alias
   script="OnHelp"
   match="^pp help$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
</aliases>

<triggers>
  <trigger
   enabled="y"
   match="^## You may now use projection abilities.$"
   name="pp_ready"
   script="pp_ready"
   sequence="100"
   regexp="y"
   group="pp_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^Your pulse races as magical forces build within you.$"
   name="pp_active"
   script="pp_active"
   sequence="100"
   regexp="y"
   group="pp_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^You feel your power projection fade.$"
   name="pp_limp"
   script="pp_limp"
   sequence="100"
   regexp="y"
   group="pp_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   match="^  Power projection         : enhanced magic attacks \(([0-9]+):([0-9]+)\)$"
   name="pp_check_enabled"
   script="pp_check_enabled"
   sequence="100"
   regexp="y"
   group="pp_check_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   match="^  Projection               : ([0-9]+):([0-9]+)$"
   name="pp_check_recovery"
   script="pp_check_recovery"
   sequence="100"
   regexp="y"
   group="pp_check_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   match="^Use 'saffects' to see a short version of your affects\.$"
   name="pp_check_end"
   script="pp_check_end"
   sequence="100"
   regexp="y"
   group="pp_check_group"
   omit_from_output="n"
  >
  </trigger>
</triggers>

<timers>
  <timer
      script="update_timer"
      enabled="n"
      second="30.00"
      name="pp_timer"
      >
  </timer>
</timers>

<script>
<![CDATA[

require "tprint"
require "movewindow"
require "commas"

window_init = false
win = "win" .. GetPluginID ()

time_left = 0
time_left_text = ""
recovery_left = 0
recovery_left_text = ""
last_color = "cyan"

havePP = false
havePPRecovery = false

function draw_time ()
  local text = ""
  local text_color = "black"
  if havePP then
    text = time_left_text
    text_color = "red"
  elseif havePPRecovery then
    text = recovery_left_text
    text_color = "slategray"
  end
  --Note(text, text_color)
  WindowFont (win, "f", "Inconsolata", 14, true, false, false, false) -- define font
  width   = WindowTextWidth (win, "f", text)  -- width of text  (270)
  height  = WindowFontInfo (win, "f", 1)   -- height of the font  (46)
  ascent  = WindowFontInfo (win, "f", 2)   -- ascent (amount above the baseline)  (36)
  descent = WindowFontInfo (win, "f", 3)   -- descent (amount below the baseline) (10)
  leading = WindowFontInfo (win, "f", 4)   -- leading (space above the highest letter) (9)
  WindowText (win, "f", 
                  text,   -- text
                  24, 28, 0, 0,        -- rectangle
                  ColourNameToRGB (text_color), -- colour
                  false)              -- not Unicode
end

function window_create(color)
  if window_init == false then
    WindowCreate (win, 0, 0, 70, 70, miniwin.pos_center_all, 0, ColourNameToRGB("black"))
    WindowShow (win, true)
  end
  WindowPolygon (win, "0,0,0,70,0,70,70,70,70,70,70,0,70,0,0,0",
    ColourNameToRGB("black"), miniwin.pen_solid, 4,
    ColourNameToRGB("black"), miniwin.brush_solid, true, false)
  WindowArc (win, 10, 10, 60, 60, 18, 10, 53, 10, ColourNameToRGB (color), miniwin.pen_solid, 4)
  WindowLine (win, 35, 3, 35, 28, ColourNameToRGB (color), miniwin.pen_solid, 4)
  draw_time()
  --- install the window movement handler, get back the window position.
  movewindow.add_drag_handler (win, 0, 0, 70, 70, miniwin.cursor_both_arrow)
  window_init = true
  last_color = color
end -- window_create

window_create("cyan")
windowinfo = movewindow.install (win, miniwin.pos_top_right, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=default_x, y=default_y})

function window_delete()
  WindowDelete(win)
end -- window_delete

function OnPluginInstall ()
   windowinfo = movewindow.install (win, miniwin.pos_top_right, miniwin.create_absolute_location, false, nil, {mouseup=MouseUp, mousedown=LeftClickOnly, dragmove=LeftClickOnly, dragrelease=LeftClickOnly},{x=default_x, y=default_y})
end

function OnPluginSaveState ()
   -- save window current location for next time
   movewindow.save_state (win)
end

function OnPluginDisable ()
  window_delete()
end -- function

function pp_active()
  pp_check()
  window_create("red")
end -- pp_active

function pp_ready()
  time_left = 0
  recovery_left = 0
  time_left_text = ""
  recovery_left_text = ""
  EnableTimer("pp_timer", false)
  window_create("yellow")
end -- pp_ready

function pp_limp()
  havePP = false
  window_create("slategray")
end -- pp_limp

function pp_check()
  EnableTriggerGroup("pp_check_group", true)
  havePP = false
  havePPRecovery = false
  Send("aff project")
end -- pp_check

pp_check()

function pp_check_enabled(name, line, wildcards)
  havePP = true
  local minutes = tonumber(wildcards[1])
  local seconds = tonumber(wildcards[2])
  time_left = minutes * 60 + seconds
  time_left_text = convert_time(time_left)
  time_left_text = time_left_text:gsub("%s+", "")
end -- pp_check_enabled

function pp_check_recovery(name, line, wildcards)
  havePPRecovery = true
  local minutes = tonumber(wildcards[1])
  local seconds = tonumber(wildcards[2])
  recovery_left = minutes * 60 + seconds
  recovery_left_text = convert_time(recovery_left)
  recovery_left_text = recovery_left_text:gsub("%s+", "")
end -- pp_check_recovery

function pp_check_end()
  EnableTriggerGroup("pp_check_group", false)
  EnableTimer("pp_timer", true)
  if havePP then
    pp_active()
    return
  end
  if havePPRecovery then
    pp_limp()
    return
  end
  pp_ready()
end -- pp_check_end

function update_timer ()
  -- Note(time_left, time_left_text, recovery_left, recovery_left_text)
  if time_left > 0 then
    time_left = time_left - 30
  end
  if recovery_left > 0 then
    recovery_left = recovery_left - 30
  end
  if time_left < 0 then
   time_left = 0
  end
  if recovery_left < 0 then
   recovery_left = 0
  end
  time_left_text = convert_time(time_left)
  time_left_text = time_left_text:gsub("%s+", "")
  recovery_left_text = convert_time(recovery_left)
  recovery_left_text = recovery_left_text:gsub("%s+", "")
  window_create(last_color)
end

-- Window Stuff --

-- Utils  --

function tableCountItems(ttable)
  local count = 0
  for i,v in pairs(ttable) do
    count = count + 1
  end
  if count == 0 then
    for i,v in ipairs(ttable) do
      count = count + 1
    end
  end
  return count
end

function padRight(text, length, padChar)
  local padding = length - string.len(text)
  for i = 1, padding do
    text = text .. padChar
  end
  return text
end

function trim(s)
  return s:match "^%s*(.-)%s*$"
end

function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

]]>
</script> 
</muclient>
