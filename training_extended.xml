<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, February 27, 2018, 8:08 PM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "training_extended" generated by Plugin Wizard -->

<muclient>
<plugin
   name="training_extended"
   author="Daak"
   id="5a0cf36701b3f475a9e013e8"
   language="Lua"
   purpose="Training Extending inlcudes Max training and Practice All"
   save_state="y"
   date_written="2018-02-27 20:02:14"
   requires="5.06"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Allows you to train in the following ways:

  xtrain all            - Trains all stats 1 time
  xtrain # all          - Train all stats # of times
  xtrain str dex luck   - Train specific starts once
  xtrain # str dex luck - Train specific starts # of times
  xtrain sdl            - Train specifc stats using short code (s)tr, (i)nt, (w)is, (d)ex, (c)con, (l)uck one time
  xtrain # sdl          - Train specifc stats using short code (s)tr, (i)nt, (w)is, (d)ex, (c)con, (l)uck # of times
  xtrain ssddllc        - Same as above, but lets multiple stats in a short way
  xtrain max str        - Train str to max
  xtrain max str dex    - Max can take multiple stats
  xtrain max sdl        - And short versions as well
  xprac all             - Practices all available skills/spells

Suggested alias: #alias {tra *} {xtrain %1}

Passing any unmatched parameters to in-game train command.
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Plugin help  -->

<aliases>
</aliases>

<aliases>
  <alias
    match="^dprac (?&lt;cmd&gt;.*)$"
    script="prac_start"
    name="prac_start"
    enabled="y" regexp="y" sequence="100" ignore_case="y"
    >
  </alias>
  <alias match="^xtrai?n?$"
    script="OnHelp"
    enabled="y" regexp="y" sequence="100" ignore_case="y"
    >
  </alias>
  <alias match="^xtrai?n? all$"
    script="train"
    name="train_all"
    enabled="y" regexp="y" sequence="100" ignore_case="y"
    >
  </alias>
  <alias match="^xtrai?n? (?&lt;amount&gt;\d+) all$"
    script="train"
    name="train_all_number"
    enabled="y" regexp="y" sequence="100" ignore_case="y"
    >
  </alias>
  <alias match="^xtrai?n? max (?&lt;params&gt;.*)$"
    script="train"
    name="train_params_max"
    enabled="y" regexp="y" sequence="199" ignore_case="y"
    >
  </alias>
  <alias match="^xtrai?n? (?&lt;amount&gt;\d+) (?&lt;params&gt;.*)$"
    script="train"
    name="train_params_number"
    enabled="y" regexp="y" sequence="200" ignore_case="y"
    >
  </alias>
  <alias match="^xtrai?n? (?&lt;params&gt;.*)$"
    script="train"
    name="train_params"
    enabled="y" regexp="y" sequence="201" ignore_case="y"
    >
  </alias>
  <alias
   script="OnHelp"
   match="^xtrai?n? help$"
   enabled="y" regexp="y" sequence="100" ignore_case="y"
  >
  </alias>
</aliases>

<triggers>
  <trigger
   enabled="n"
   match="^(?&lt;skill&gt;[^\d-]+)(\d|-).*$"
   name="prac_skill"
   script="prac_skill"
   sequence="100"
   regexp="y"
   group="prac_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   match="^See 'help learned' for better ways to list skill/spell proficiency.$"
   name="prac_end"
   script="prac_end"
   sequence="100"
   regexp="y"
   group="prac_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   match="^(?&lt;statlong&gt;Strength|Intelligence|Wisdom|Dexterity|Constitution|Luck) *:.{35} *(?&lt;statcur&gt;\d+) *(?&lt;statmax&gt;\d+)$"
   name="maxstat_line"
   script="maxstat_line"
   sequence="100"
   regexp="y"
   group="maxstat_group"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   match="^You have \d+ total stats out of \d+ maximum.$"
   name="maxstat_end"
   script="maxstat_end"
   sequence="100"
   regexp="y"
   group="maxstat_group"
   omit_from_output="n"
  >
  </trigger>
</triggers>

<script>
<![CDATA[

require "tprint"

skills_count = 0
skills_found = {}
curstats = {}
maxstats = {}
do_practice = 0
saved_params = ""

function prac_start (name, line, wildcards)
  local cmd = wildcards.cmd
  if cmd ~= "all" and cmd ~= "list" and cmd ~= "help" then
    Note("Invalid dprac command - try: dprac <all|list|help>")
    return
  end
  if cmd == "help" then
    show_prac_help()
    return
  end
  do_practice = 0
  if cmd == "all" then
    do_practice = 1
  end
  EnableTriggerGroup("prac_group", true)
  skills_count = 0;
  skills_found = {}
  Send("prac")
end -- prac_start

function prac_skill (name, line, wildcards)
  --  Wrath of god              166     1%
  -- Note(wildcards.skill)
  skill = trim(wildcards.skill)
  -- Note(skill)
  -- You have 62 training sessions available.
  -- You have 162 practice sessions available.
  if skill == "You have" then
    return
  end
  table.insert(skills_found, {skillname=skill})
  skills_count = skills_count + 1
end -- prac_skill

function prac_end (name, line, wildcards)
  Note("Loaded " .. skills_count .. " skills to pratice")
  EnableTriggerGroup("prac_group", false)
  -- tprint(skills_found)
  prac_all()
end -- prac_end

function get_max_stats ()
  curstats = {}
  maxstats = {}
  EnableTriggerGroup("maxstat_group", true)
  Send("train")
end -- get_max_stats

function maxstat_line (name, line, wildcards)
  --  Strength     :      1     -1      0      0      1       51       52
  local shortstats = {["Strength"] = "str", ["Intelligence"] = "int", ["Wisdom"] = "wis", ["Dexterity"] = "dex", ["Constitution"] = "con", ["Luck"] = "luck"}
  local stat = shortstats[wildcards.statlong]
  if stat == nil then
    Note("xtrain - Error - Unexpected Stat found " .. wildcards.statlong)
    return
  end
  local statmax = tonumber(wildcards.statmax)
  if statmax ~= nil then
    --Note(stat .. " max = " .. statmax)
    maxstats[stat] = statmax
  end
  local statcur = tonumber(wildcards.statcur)
  if statcur ~= nil then
    --Note(stat .. " cur = " .. statcur)
    curstats[stat] = statcur
  end
end -- maxstat_line

function maxstat_end (name, line, wildcards)
  --Note("maxstat_end called")
  --tprint(maxstats)
  EnableTriggerGroup("maxstat_group", false)
  local pass = {}
  pass.params = saved_params
  train("train_params_have_maxstats", "", pass)
end -- maxstat_end

function prac_all ()
  if skills_count < 1 then
    Note("No skills to practice.")
    return
  end
  if do_practice == 0 then
    Note("dprac all will practice skills below:")
  end
  for i,v in ipairs(skills_found) do
    if do_practice == 1 then
      Send("prac " .. v.skillname .. " full")
    else
      Note(v.skillname)
    end
  end -- for
end -- prac_all

function train (name, line, wildcards)
  local params = wildcards.params
  local stats_to_train = {}
  if params == "help" then
    OnHelp()
    return
  end
  local pass_thru = 0
  local trains = {}
  local stats = {}
  local amount_to_train = 1
  if name == "train_all" or name == "train_all_number" then
    if name == "train_all_number" then
      amount_to_train = wildcards.amount
    end
    table.insert(trains, {stat="str",amount=amount_to_train})
    table.insert(trains, {stat="int",amount=amount_to_train})
    table.insert(trains, {stat="wis",amount=amount_to_train})
    table.insert(trains, {stat="dex",amount=amount_to_train})
    table.insert(trains, {stat="con",amount=amount_to_train})
    table.insert(trains, {stat="luck",amount=amount_to_train})
  elseif name == "train_params" or name =="train_params_number" then
    if name == "train_params_number" then
      amount_to_train = wildcards.amount
    end
    stats_to_train = parse_params(wildcards.params)
    if tableCountItems(stats_to_train) > 0 then
      for i,v in pairs(stats_to_train) do
        table.insert(trains, {stat=v,amount=amount_to_train})
      end
    end
  elseif name == "train_params_max" then
    get_max_stats()
    saved_params = wildcards.params
    return
  elseif name == "train_params_have_maxstats" then
    stats_to_train = parse_params(wildcards.params)
    if tableCountItems(stats_to_train) > 0 then
      for i,v in pairs(stats_to_train) do
        if maxstats[v] ~= nil and curstats[v] ~= nil then
          local amount_to_max = maxstats[v] - curstats[v]
          if amount_to_max > 0 then
            table.insert(trains, {stat=v,amount=amount_to_max})
          end
        end
      end
    end
    if tableCountItems(trains) == 0 then
      Note("\nDesired stats are already at max.")
      return
    end
  else
    pass_thru = 1
  end
  if pass_thru == 1 then
    Note("Sending to in-game train")
    if wildcards[2] ~= nil then
      Send("train " .. wildcards[1] .. " " .. wildcards[2])
    else
      Send("train " .. wildcards[1])
    end
    return
  end
  if tableCountItems(trains) > 0 then
    --tprint(trains)
    local combined_trains = {}
    combined_trains["str"] = 0
    combined_trains["int"] = 0
    combined_trains["wis"] = 0
    combined_trains["dex"] = 0
    combined_trains["con"] = 0
    combined_trains["luck"] = 0
    for i,v in ipairs(trains) do
      combined_trains[v.stat] = combined_trains[v.stat] + v.amount
    end
    --tprint(combined_trains)
    for i,v in pairs(combined_trains) do
      if v > 0 then
        Send("train " .. v .. " " .. i)
      end
    end
  else
    Note("Failed to load anything to xtrain, passing to in-game train")
    Send("train " .. wildcards[1])
    return
  end
end -- train

function parse_params (params)
  local return_stats = {}
  for i in string.gmatch(params, "%S+") do
    if i == "str" or i == "int" or i == "wis" or i == "dex" or i == "con" or i == "luck" then
      table.insert(return_stats, i)
    else
      -- parse potential siwdcl string
      local matches = string.match(params, "^([siwdcl]+)$");
      if matches ~= nil then
        for i in string.gmatch(params, "[siwdcl]") do
          local stat_name = ""
          if i == "s" then
            stat_name = "str"
          elseif i == "i" then
            stat_name = "int"
          elseif i == "w" then
            stat_name = "wis"
          elseif i == "d" then
            stat_name = "dex"
          elseif i == "c" then
            stat_name = "con"
          elseif i == "l" then
            stat_name = "luck"
          end
          if stat_name ~= "" then
            table.insert(return_stats, stat_name)
          end
        end
      end
    end
  end
  --tprint(return_stats)
  return return_stats
end
  
function show_prac_help ()
  Note("Help for Daak's Practice All:\n")
  Tell(padRight("  dprac all", 12, " "))
  Note(": Practice All available skills")
  Tell(padRight("  dprac list", 12, " "))
  Note(": List All available skills to be practiced")
  Tell(padRight("  dprac help", 12, " "))
  Note(": You're looking at it\n")
  Note("This does plugin doesn't compute required practices (yet?)")
end -- show_prac_help

-- Utils  --

function tableCountItems(ttable)
  local count = 0
  for i,v in pairs(ttable) do
    count = count + 1
  end
  if count == 0 then
    for i,v in ipairs(ttable) do
      count = count + 1
    end
  end
  return count
end

function padRight(text, length, padChar)
  local padding = length - string.len(text)
  for i = 1, padding do
    text = text .. padChar
  end
  return text
end

function trim(s)
  return s:match "^%s*(.-)%s*$"
end

function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

]]>
</script> 

</muclient>
